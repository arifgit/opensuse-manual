<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="tuning_systemtap.xml" id="cha.tuning.systemtap">
 <title>SystemTap—Filtering and Analyzing System Data</title>



 <para>
  SystemTap provides a command line interface and a scripting language to
  examine the activities of a running Linux system, particularly the kernel,
  in fine detail. SystemTap scripts are written in the SystemTap scripting
  language, are then compiled to C-code kernel modules and inserted into the
  kernel. The scripts can be designed to extract, filter and summarize data,
  thus allowing the diagnosis of complex performance problems or functional
  problems. SystemTap provides information similar to the output of tools like
  <command>netstat</command>, <command>ps</command>, <command>top</command>,
  and <command>iostat</command>. However, more filtering and analysis
  options can be used for the collected information.
 </para>


 <sect1 id="sec.tuning.systemtap.concept">
  <title>Conceptual Overview</title>

  <para>
   Each time you run a SystemTap script, a SystemTap session is started. A number
   of passes are done on the script before it is allowed to run, at which
   point the script is compiled into a kernel module and loaded. In case the
   script has already been executed before and no changes regarding any
   components have occurred (for example, regarding compiler version, kernel
   version, library path, script contents), SystemTap does not compile the
   script again, but uses the <filename>*.c</filename> and
   <filename>*.ko</filename> data stored in the SystemTap cache
   (<filename>~/.systemtap</filename>). The module is unloaded when the tap
   has finished running. For an example, see the test run in
   <xref linkend="sec.tuning.systemtap.setup"/> and the respective
   explanation.

  </para>

  <sect2 id="sec.tuning.systemtap.concept.scripts">
   <title>SystemTap Scripts</title>
   <para>
    SystemTap usage is based on SystemTap scripts (<filename>*.stp</filename>).
    They tell SystemTap which type of information to collect, and what to do
    once that information is collected. The scripts are written in the
    SystemTap scripting language that is similar to AWK and C. For the language
    definition, see
    <ulink url="http://sourceware.org/systemtap/langref/"/>.
   </para>
   <para>
    The essential idea behind a SystemTap script is to name
    <literal>events</literal>, and to give them <literal>handlers</literal>.
    When SystemTap runs the script, it monitors for certain events. When an
    event occurs, the Linux kernel runs the handler as a sub-routine, then
    resumes. Thus, events serve as the triggers for handlers to run.
    Handlers can record specified data and print it in a certain manner.
   </para>
   <para>
    The SystemTap language only uses a few data types (integers, strings, and
    associative arrays of these), and full control structures (blocks,
    conditionals, loops, functions). It has a lightweight punctuation
    (semicolons are optional) and does not need detailed declarations (types
    are inferred and checked automatically).
   </para>
   <para>
    For more information about SystemTap scripts and their syntax, refer to
    <xref linkend="sec.tuning.systemtap.syntax"/> and to the
    <command>stapprobes</command> and <command>stapfuncs</command> man
    pages, that are available with the
    <systemitem class="resource">systemtap-docs</systemitem> package.
   </para>
  </sect2>

  <sect2 id="sec.tuning.systemtap.concept.tapsets">
   <title>Tapsets</title>
   <para>
    Tapsets are a library of pre-written probes and functions that can be
    used in SystemTap scripts. When a user runs a SystemTap script, SystemTap checks
    the script's probe events and handlers against the tapset library.
    SystemTap then loads the corresponding probes and functions before
    translating the script to C. Like SystemTap scripts themselves, tapsets use
    the filename extension <filename>*.stp</filename>.

   </para>
   <para>
    However, unlike SystemTap scripts, tapsets are not meant for direct
    execution—they constitute the library from which other scripts can
    pull definitions. Thus, the tapset library is an abstraction layer
    designed to make it easier for users to define events and functions.
    Tapsets provide useful aliases for functions that users may want to
    specify as an event (knowing the proper alias is mostly easier than
    remembering specific kernel functions that might vary between kernel
    versions).
   </para>
  </sect2>

  <sect2 id="sec.tuning.systemtap.concept.cmd">
   <title>Commands and Privileges</title>
   <para>
    The main commands associated with SystemTap are <command>stap</command> and
    <command>staprun</command>. To execute them, you either need <systemitem class="username">root</systemitem>
    privileges or must be a member of the
    <systemitem class="groupname">stapdev</systemitem> or
    <systemitem class="groupname">stapusr</systemitem> group.
   </para>
   <variablelist>
    <varlistentry>
     <term><command>stap</command>
     </term>
     <listitem>
      <para>
       SystemTap front-end. Runs a SystemTap script (either from file, or from
       standard input). It translates the script into C code, compiles it,
       and loads the resulting kernel module into a running Linux kernel.
       Then, the requested system trace or probe functions are performed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><command>staprun</command>
     </term>
     <listitem>
      <para>
       SystemTap back-end. Loads and unloads kernel modules produced by the
       SystemTap front-end.

      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For a list of options for each command, use <option>--help</option>. For
    details, refer to the <command>stap</command> and the
    <command>staprun</command> man pages.
   </para>


   <para>
    To avoid giving <systemitem class="username">root</systemitem> access to users just for running SystemTap, you
    can make use of the following SystemTap groups. They are not available by
    default on <phrase os="osuse">openSUSE</phrase>, but you can create the groups and modify the
    access rights accordingly.
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="groupname">stapdev</systemitem>
     </term>
     <listitem>
      <para>
       Members of this group can run SystemTap scripts with
       <command>stap</command>, or run SystemTap instrumentation modules with
       <command>staprun</command>. As running <command>stap</command>
       involves compiling scripts into kernel modules and loading them into
       the kernel, members of this group still have effective <systemitem class="username">root</systemitem>
       access.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="groupname">stapusr</systemitem>
     </term>
     <listitem>
      <para>
       Members of this group are only allowed to run SystemTap instrumentation
       modules with <command>staprun</command>. In addition, they can only
       run those modules from
       <filename>/lib/modules/<replaceable>kernel_version</replaceable>/systemtap/</filename>.
       This directory must be owned by <systemitem class="username">root</systemitem> and must only be writable
       for the <systemitem class="username">root</systemitem> user.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="sec.tuning.systemtap.concept.dir">
   <title>Important Files and Directories</title>
   <para>
    The following list gives an overview of the SystemTap main files and
    directories.
   </para>
   <variablelist>
    <varlistentry>
     <term><filename>/lib/modules/<replaceable>kernel_version</replaceable>/systemtap/</filename>
     </term>
     <listitem>
      <para>
       Holds the SystemTap instrumentation modules.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/systemtap/tapset/</filename>
     </term>
     <listitem>
      <para>
       Holds the standard library of tapsets.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/doc/packages/systemtap/examples</filename>
     </term>
     <listitem>
      <para>
       Holds a number of example SystemTap scripts for various purposes. Only
       available if the
       <systemitem class="resource">systemtap-docs</systemitem> package is
       installed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/cache</filename>
     </term>
     <listitem>
      <para>
       Data directory for cached SystemTap files.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/tmp/stap*</filename>
     </term>
     <listitem>
      <para>
       Temporary directory for SystemTap files, including translated C code and
       kernel object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>


  </sect2>
 </sect1>
 <sect1 id="sec.tuning.systemtap.setup">
  <title>Installation and Setup</title>

  <para>


   As SystemTap needs information about the kernel, some kernel-related
   packages must be installed in addition to the SystemTap packages. For each
   kernel you want to probe with SystemTap, you need to install a set of the
   following packages that exactly matches the kernel version and flavor
   (indicated by <literal>*</literal> in the overview below).
  </para>

  <important>
   <title>Repository for Packages with Debugging Information</title>
   <para>
    If you subscribed your system for online updates, you can find
    <quote>debuginfo</quote> packages in the
    <literal>*-Debuginfo-Updates</literal> online installation repository
    relevant for <phrase os="osuse">openSUSE</phrase> <phrase os="osuse">12.3</phrase>. Use YaST to enable the
    repository.
   </para>
  </important>









  <para>

   For the classic SystemTap setup, install the following packages (using
   either YaST or <command>zypper</command>).
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <systemitem class="resource">systemtap</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">systemtap-server</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">systemtap-docs</systemitem> (optional)
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-*-base</systemitem>
    </para>
   </listitem>

   <listitem>
    <para>
     <systemitem class="resource">kernel-*-debuginfo</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-*-devel</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-source-*</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">gcc</systemitem>
    </para>
   </listitem>
  </itemizedlist>



  <para>
   To get access to the man pages and to a helpful collection of example
   SystemTap scripts for various purposes, additionally install the
   <systemitem class="resource">systemtap-docs</systemitem> package.
  </para>

  <para>
   To check if all packages are correctly installed on the machine and if
   SystemTap is ready to use, execute the following command as <systemitem class="username">root</systemitem>.
  </para>

  <screen>stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'</screen>

  <para>
   It probes the currently used kernel by running a script and returning an
   output. If the output is similar to the following, SystemTap is successfully
   deployed and ready to use:
  </para>

  <screen><?dbsuse-fo font-size="0.71em"?>
Pass <co id="co.tuning.stap.pass1"/>: parsed user script and 59 library script(s) in 80usr/0sys/214real ms.
Pass <co id="co.tuning.stap.pass2"/>: analyzed script: 1 probe(s), 11 function(s), 2 embed(s), 1 global(s) in 
 140usr/20sys/412real ms. 
Pass <co id="co.tuning.stap.pass3"/>: translated to C into
 "/tmp/stapDwEk76/stap_1856e21ea1c246da85ad8c66b4338349_4970.c" in 160usr/0sys/408real ms. 
Pass <co id="co.tuning.stap.pass4"/>: compiled C into "stap_1856e21ea1c246da85ad8c66b4338349_4970.ko" in 
 2030usr/360sys/10182real ms. 
Pass <co id="co.tuning.stap.pass5"/>: starting run. 
 read performed
Pass <xref linkend="co.tuning.stap.pass5"/>: run completed in 10usr/20sys/257real ms. </screen>

  <calloutlist>
   <callout arearefs="co.tuning.stap.pass1">
    <para>
     Checks the script against the existing tapset library in
     <filename>/usr/share/systemtap/tapset/</filename> for any tapsets used.
     Tapsets are scripts that form a library of pre-written probes and
     functions that can be used in SystemTap scripts.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass2">
    <para>
     Examines the script for its components.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass3">
    <para>
     Translates the script to C. Runs the system C compiler to create a
     kernel module from it. Both the resulting C code
     (<filename>*.c</filename>) and the kernel module
     (<filename>*.ko</filename>) are stored in the SystemTap cache,
     <filename>~/.systemtap</filename>.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass4">
    <para>
     Loads the module and enables all the probes (events and handlers) in
     the script by hooking into the kernel. The event being probed is a
     Virtual File System (VFS) read. As the event occurs on any processor, a
     valid handler is executed (prints the text <literal>read
     performed</literal>) and closed with no errors.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass5">
    <para>
     After the SystemTap session is terminated, the probes are disabled, and
     the kernel module is unloaded.
    </para>
   </callout>
  </calloutlist>

  <para>
   In case any error messages appear during the test, check the output for
   hints about any missing packages and make sure they are installed
   correctly. Rebooting and loading the appropriate kernel may also be
   needed.
   
  </para>




 </sect1>
 <sect1 id="sec.tuning.systemtap.syntax">
  <title>Script Syntax</title>

  <para>
   SystemTap scripts consist of the following two components:
  </para>

  <variablelist>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.events" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      Name the kernel events at the associated handler should be executed.
      Examples for events are entering or exiting a certain function, a
      timer expiring, or starting or terminating a session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.handlers" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      Series of script language statements that specify the work to be done
      whenever a certain event occurs. This normally includes extracting
      data from the event context, storing them into internal variables, or
      printing results.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   An event and its corresponding handler is collectively called a
   <literal>probe</literal>. SystemTap events are also called <literal>probe
   points</literal>. A probe's handler is also referred to as <literal>probe
   body</literal>.
  </para>

  <para>
   Comments can be inserted anywhere in the SystemTap script in various styles:
   using either <literal>#</literal>, <literal>/* */</literal>, or
   <literal>//</literal> as marker.
  </para>

  <sect2 id="sec.tuning.systemtap.syntax.probe">
   <title>Probe Format</title>
   <para>
    A SystemTap script can have multiple probes. They must be written in the
    following format:
   </para>
   <screen>probe <replaceable>event</replaceable> {<replaceable>statements</replaceable>}</screen>
   <para>
    Each probe has a corresponding statement block. This statement block
    must be enclosed in <literal>{ }</literal> and contains the statements
    to be executed per event.
   </para>
   <example id="ex.tuning.stap.simple">
    <title>Simple SystemTap Script</title>
    <para>
     The following example shows a simple SystemTap script.
    </para>
    <screen>probe<co id="co.tuning.stap.probe"/> begin<co id="co.tuning.stap.event.begin"/>
{<co id="co.tuning.stap.handler.start"/>
   printf<co id="co.tuning.stap.handler.function.printf"/> ("hello world\n")<co id="co.tuning.stap.handler.string"/>
   exit ()<co id="co.tuning.stap.handler.function.exit"/>
}<co id="co.tuning.stap.handler.end"/></screen>
    <calloutlist>
     <callout arearefs="co.tuning.stap.probe">
      <para>
       Start of the probe.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.event.begin">
      <para>
       Event <literal>begin</literal> (the start of the SystemTap session).
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.start">
      <para>
       Start of the handler definition, indicated by <literal>{</literal>.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.printf">
      <para>
       First function defined in the handler: the <literal>printf</literal>
       function.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.string">
      <para>
       String to be printed by the <literal>printf</literal> function,
       followed by a line break (<literal>/n</literal>).
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.exit">
      <para>
       Second function defined in the handler: the <literal>exit()</literal>
       function. Note that the SystemTap script will continue to run until the
       <literal>exit()</literal> function executes. If you want to stop the
       execution of the script before, stop it manually by pressing
       <keycombo> <keycap function="control"/> <keycap>C</keycap>
       </keycombo>.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.end">
      <para>
       End of the handler definition, indicated by <literal>}</literal>.
      </para>
     </callout>
    </calloutlist>
    <para>
     The event <literal>begin</literal>
     <xref linkend="co.tuning.stap.event.begin" xrefstyle="select:label nopage"/>
     (the start of the SystemTap session) triggers the handler enclosed in
     <literal>{ }</literal>, in this case the <literal>printf</literal>
     function
     <xref linkend="co.tuning.stap.handler.function.printf" xrefstyle="select:label nopage"/>
     which prints <literal>hello world</literal> followed by a new line
     <xref linkend="co.tuning.stap.handler.string" xrefstyle="select:label nopage"/>,
     then exits.
    </para>
   </example>
   <para>
    If your statement block holds several statements, SystemTap executes these
    statements in sequence—you do not need to insert special
    separators or terminators between multiple statements. A statement block
    can also be nested within another statement blocks. Generally, statement
    blocks in SystemTap scripts use the same syntax and semantics as in the C
    programming language.
   </para>
  </sect2>

<?dbfo-need height="20em"?>


  <sect2 id="sec.tuning.systemtap.syntax.events">
   <title>SystemTap Events (Probe Points)</title>
   <para>
    SystemTap supports a number of built-in events.
   </para>
   <para>
    The general event syntax is a dotted-symbol sequence. This allows a
    breakdown of the event namespace into parts. Each component identifier
    may be parametrized by a string or number literal, with a syntax like a
    function call. A component may include a <literal>*</literal> character,
    to expand to other matching probe points. A probe point may be followed
    by a <literal>?</literal> character, to indicate that it is optional,
    and that no error should result if it fails to expand.
    
    Alternately, a probe point may be followed by a <literal>!</literal>
    character to indicate that it is both optional and sufficient.
   </para>
   <para>
    SystemTap supports multiple events per probe—they need to be
    separated by a comma (<literal>,</literal>). If multiple events are
    specified in a single probe, SystemTap will execute the handler when any of
    the specified events occur.
   </para>
   <para>
    In general, events can be classified into the following categories:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Synchronous events: Occur when any process executes an instruction at
      a particular location in kernel code. This gives other events a
      reference point (instruction address) from which more contextual data
      may be available.
     </para>
     <para>
      An example for a synchronous event is
      <literal>vfs.<replaceable>file_operation</replaceable></literal>: The
      entry to the <replaceable>file_operation</replaceable> event for
      Virtual File System (VFS). For example, in
      <xref linkend="sec.tuning.systemtap.setup"/>, <literal>read</literal>
      is the <replaceable>file_operation</replaceable> event used for VFS.



     </para>
    </listitem>
    <listitem>
     <para>
      Asynchronous events: Not tied to a particular instruction or location
      in code. This family of probe points consists mainly of counters,
      timers, and similar constructs.
     </para>
     <para>
      Examples for asynchronous events are: <literal>begin</literal> (start
      of a SystemTap session—as soon as a SystemTap script is run,
      <literal>end</literal> (end of a SystemTap session), or timer events.
      Timer events specify a handler to be executed periodically, like
      <literal>example
      timer.s(<replaceable>seconds</replaceable>)</literal>, or
      <literal>timer.ms(<replaceable>milliseconds</replaceable>)</literal>.
     </para>
     <para>
      When used in conjunction with other probes that collect information,
      timer events allow you to print out periodic updates and see how that
      information changes over time.
     </para>
    </listitem>
   </itemizedlist>
   <example id="ex.tuning.stap.async">
    <title>Probe with Timer Event</title>
    <para>
     For example, the following probe would print the text <quote>hello
     world</quote> every 4 seconds:
    </para>
    <screen>probe timer.s(4)
{
   printf("hello world\n")
}</screen>
   </example>
   <para>
    For detailed information about supported events, refer to the
    <command>stapprobes</command> man page. The <citetitle>See
    Also</citetitle> section of the man page also contains links to other
    man pages that discuss supported events for specific subsystems and
    components.
   </para>
  </sect2>

  <sect2 id="sec.tuning.systemtap.syntax.handlers">
   <title>SystemTap Handlers (Probe Body)</title>
   <para>
    Each SystemTap event is accompanied by a corresponding handler defined for
    that event, consisting of a statement block.
   </para>
   <sect3 id="sec.tuning.systemtap.syntax.handlers.functions">
    <title>Functions</title>
    <para>
     If you need the same set of statements in multiple probes, you can
     place them in a function for easy reuse. Functions are defined by the
     keyword <literal>function</literal> followed by a name. They take any
     number of string or numeric arguments (by value) and may return a
     single string or number.
    </para>
    <screen>function <replaceable>function_name</replaceable>(<replaceable>arguments</replaceable>) {<replaceable>statements</replaceable>}
probe <replaceable>event</replaceable> {<replaceable>function_name</replaceable>(<replaceable>arguments</replaceable>)}</screen>
    <para>
     The statements in <replaceable>function_name</replaceable> are executed
     when the probe for <replaceable>event</replaceable> executes. The
     <replaceable>arguments</replaceable> are optional values passed into
     the function.
    </para>
    <para>
     Functions can be defined anywhere in the script. They may take any
    </para>
    <para>
     One of the functions needed very often was already introduced in
     <xref linkend="ex.tuning.stap.simple"/>: the
     <literal>printf</literal> function for printing data in a formatted
     way. When using the <literal>printf</literal> function, you can specify
     how arguments should be printed by using a format string. The format
     string is included in quotation marks and can contain further format
     specifiers, introduced by a <literal>%</literal> character.
    </para>
    <para>
     Which format strings to use depends on your list of arguments. Format
     strings can have multiple format specifiers—each matching a
     corresponding argument. Multiple arguments can be separated by a comma.
    </para>
    <example id="ex.tuning.stap.printf.formatspec">
     <title><literal>printf</literal> Function with Format Specifiers</title>
     <screen>printf ("<co id="co.tuning.stap.formatstring.start"/>%s<co id="co.tuning.stap.string.spec"/>(%d<co id="co.tuning.stap.int.spec"/>) open\n<co id="co.tuning.stap.formatstring.end"/>", execname(), pid())</screen>
     <calloutlist>
      <callout arearefs="co.tuning.stap.formatstring.start">
       <para>
        Start of the format string, indicated by <literal>"</literal>.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.string.spec">
       <para>
        String format specifier.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.int.spec">
       <para>
        Integer format specifier.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.formatstring.end">
       <para>
        End of the format string, indicated by <literal>"</literal>.
       </para>
      </callout>
     </calloutlist>
    </example>
    <para>
     The example above would print the current executable name
     (<literal>execname()</literal>) as string and the process ID
     (<literal>pid()</literal>) as integer in brackets, followed by a space,
     then the word <literal>open</literal> and a line break:
    </para>
    <screen>[...]
vmware-guestd(2206) open
hald(2360) open
[...]
   </screen>
    <para>
     Apart from the two functions <literal>execname()</literal>and
     <literal>pid()</literal>) used in
     <xref linkend="ex.tuning.stap.printf.formatspec"/>, a variety of
     other functions can be used as <literal>printf</literal> arguments.
    </para>
    <para>
     Among the most commonly used SystemTap functions are the following:
    </para>
    <variablelist>
     <varlistentry>
      <term>tid()</term>
      <listitem>
       <para>
        ID of the current thread.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pid()</term>
      <listitem>
       <para>
        Process ID of the current thread.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>uid()</term>
      <listitem>
       <para>
        ID of the current user.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cpu()</term>
      <listitem>
       <para>
        Current CPU number.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>execname()</term>
      <listitem>
       <para>
        Name of the current process.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>gettimeofday_s()</term>
      <listitem>
       <para>
        Number of seconds since UNIX epoch (January 1, 1970).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ctime()</term>
      <listitem>
       <para>
        Convert time into a string.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pp()</term>
      <listitem>
       <para>
        String describing the probe point currently being handled.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>thread_indent()</term>
      <listitem>
       <para>
        Useful function for organizing print results. It (internally) stores
        an indentation counter for each thread (<literal>tid()</literal>).
        The function takes one argument, an indentation delta, indicating
        how many spaces to add or remove from the thread's indentation
        counter. It returns a string with some generic trace data along with
        an appropriate number of indentation spaces. The generic data
        returned includes a timestamp (number of microseconds since the
        initial indentation for the thread), a process name, and the thread
        ID itself. This allows you to identify what functions were called,
        who called them, and how long they took.
       </para>
       <para>
        Call entries and exits often do not immediately precede each other
        (otherwise it would be easy to match them). In between a first call
        entry and its exit, usually a number of other call entries and exits
        are made. The indentation counter helps you match an entry with its
        corresponding exit as it indents the next function call in case it
        is <emphasis>not</emphasis> the exit of the previous one. For an
        example SystemTap script using <literal>thread_indent()</literal> and
        the respective output, refer to the <citetitle>SystemTap
        Tutorial</citetitle>:
        <ulink url="http://sourceware.org/systemtap/tutorial/Tracing.html#fig:socket-trace"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     For more information about supported SystemTap functions, refer to the
     <command>stapfuncs</command> man page.
    </para>
   </sect3>
   <sect3 id="sec.tuning.systemtap.syntax.handlers.others">
    <title>Other Basic Constructs</title>
    <para>
     Apart from functions, you can use several other common constructs in
     SystemTap handlers, including variables, conditional statements (like
     <literal>if</literal>/<literal>else</literal>, <literal>while</literal>
     loops, <literal>for</literal> loops, arrays or command line arguments.
    </para>
    <sect4 id="sec.tuning.systemtap.syntax.handlers.others.variables">
     <title>Variables</title>
     <para>
      Variables may be defined anywhere in the script. To define one, simply
      choose a name and assign a value from a function or expression to it:
     </para>
     <screen>foo = gettimeofday( )</screen>
     <para>
      Then you can use the variable in an expression. From the type of
      values assigned to the variable, SystemTap automatically infers the type
      of each identifier (string or number). Any inconsistencies will be
      reported as errors. In the example above, <literal>foo</literal> would
      automatically be classified as a number and could be printed via
      <literal>printf()</literal> with the integer format specifier
      (<literal>%d</literal>).
     </para>
     <para>
      However, by default, variables are local to the probe they are used
      in: They are initialized, used and disposed of at each handler
      evocation. To share variables between probes, declare them global
      anywhere in the script. To do so, use the <literal>global</literal>
      keyword outside of the probes:
     </para>
     <example>
      <title>Using Global Variables</title>
      <screen>global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
  hz=(1000*count_jiffies) / count_ms
  printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d\n",
    count_jiffies, count_ms, hz)
  exit ()
  }</screen>
      <para>
       This example script computes the CONFIG_HZ setting of the kernel by
       using timers that count jiffies and milliseconds, then computing
       accordingly. (A jiffy is the duration of one tick of the system timer
       interrupt. It is not an absolute time interval unit, since its
       duration depends on the clock interrupt frequency of the particular
       hardware platform). With the <literal>global</literal> statement it
       is possible to use the variables <literal>count_jiffies</literal> and
       <literal>count_ms</literal> also in the probe
       <literal>timer.ms(12345)</literal>. With <literal>++</literal> the
       value of a variable is incremented by <literal>1</literal>.
      </para>
     </example>
    </sect4>
    <sect4 id="sec.tuning.systemtap.syntax.handlers.others.conditional">
     <title>Conditional Statements</title>
     <para>
      There are a number of conditional statements that you can use in
      SystemTap scripts. The following are probably most common:
     </para>
     <variablelist>
      <varlistentry>
       <term>If/Else Statements</term>
       <listitem>
        <para>
         They are expressed in the following format:
        </para>
        <screen>if (<replaceable>condition</replaceable>)<co id="co.tuning.systemtap.cond.if"/><replaceable>statement1</replaceable><co id="co.tuning.systemtap.cond.if.statement1"/>
else<co id="co.tuning.systemtap.cond.else"/><replaceable>statement2</replaceable><co id="co.tuning.systemtap.cond.if.statement2"/></screen>
        <para>
         The <literal>if</literal> statement compares an integer-valued
         expression to zero. If the condition expression
         <xref linkend="co.tuning.systemtap.cond.if" xrefstyle="select:label nopage"/>
         is non-zero, the first statement
         <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/>
         is executed. If the condition expression is zero, the second
         statement
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>
         is executed. The else clause
         (<xref linkend="co.tuning.systemtap.cond.else" xrefstyle="select:label nopage"/>
         and
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>)
         is optional. Both
         <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/>
         and
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>
         can also be statement blocks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>While Loops</term>
       <listitem>
        <para>
         They are expressed in the following format:
        </para>
        <screen>while (<replaceable>condition</replaceable>)<co id="co.tuning.systemtap.cond.while"/><replaceable>statement</replaceable><co id="co.tuning.systemtap.cond.while.statement"/></screen>
        <para>
         As long as <literal>condition</literal> is non-zero, the statement
         <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/>
         is executed.
         <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/>
         can also be a statement block. It must change a value so
         <literal>condition</literal> will eventually be zero.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>For Loops</term>
       <listitem>
        <para>
         They are basically a shortcut for <literal>while</literal> loops
         and are expressed in the following format:
        </para>
        <screen>for (<replaceable>initialization</replaceable><co id="co.tuning.systemtap.cond.for.init"/>; <replaceable>conditional</replaceable><co id="co.tuning.systemtap.cond.for.cond"/>; <replaceable>increment</replaceable><co id="co.tuning.systemtap.cond.for.increment"/>) statement</screen>
        <para>
         The expression specified in
         <xref linkend="co.tuning.systemtap.cond.for.init" xrefstyle="select:label nopage"/>
         is used to initialize a counter for the number of loop iterations
         and is executed before execution of the loop starts. The execution
         of the loop continues until the loop condition
         <xref linkend="co.tuning.systemtap.cond.for.cond" xrefstyle="select:label nopage"/>
         is false. (This expression is checked at the beginning of each loop
         iteration). The expression specified in
         <xref linkend="co.tuning.systemtap.cond.for.increment" xrefstyle="select:label nopage"/>
         is used to increment the loop counter. It is executed at the end of
         each loop iteration.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Conditional Operators</term>
       <listitem>
        <para>
         The following operators can be used in conditional statements:
        </para>
        <formalpara>
         <title>==:</title>
         <para>
          Is equal to
         </para>
        </formalpara>
        <formalpara>
         <title>!=:</title>
         <para>
          Is not equal to
         </para>
        </formalpara>
        <formalpara>
         <title>&gt;=:</title>
         <para>
          Is greater than or equal to
         </para>
        </formalpara>
        <formalpara>
         <title>&lt;=:</title>
         <para>
          Is less than or equal to
         </para>
        </formalpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.systemtap.example">
  <title>Example Script</title>

  <para>
   If you have installed the
   <systemitem class="resource">systemtap-docs</systemitem> package,
   you can find a number of useful SystemTap example scripts in
   <filename>/usr/share/doc/packages/systemtap/examples</filename>.
  </para>

  <para>
   This section describes a rather simple example script in more detail:
   <filename>/usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</filename>.
  </para>

  <example>
   <title>Monitoring Incoming TCP Connections with <literal>tcp_connections.stp</literal></title>
   <screen>#! /usr/bin/env stap
    
probe begin {
  printf("%6s %16s %6s %6s %16s\n",
         "UID", "CMD", "PID", "PORT", "IP_SOURCE")
}
    
probe kernel.function("tcp_accept").return?,
      kernel.function("inet_csk_accept").return? {
  sock = $return
  if (sock != 0)
    printf("%6d %16s %6d %6d %16s\n", uid(), execname(), pid(),
           inet_get_local_port(sock), inet_get_ip_source(sock))
}</screen>
  </example>

  <para>
   This SystemTap script monitors the incoming TCP connections and helps to
   identify unauthorized or unwanted network access requests in real time.
   It shows the following information for each new incoming TCP connection
   accepted by the computer:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     User ID (<literal>UID</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Command accepting the connection (<literal>CMD</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Process ID of the command (<literal>PID</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Port used by the connection (<literal>PORT</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     IP address from which the TCP connection originated
     (<literal>IP_SOUCE</literal>)
    </para>
   </listitem>
  </itemizedlist>

<?dbfo-need height="15em"?>


  <para>
   To run the script, execute
  </para>

  <screen>stap /usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</screen>

  <para>
   and follow the output on the screen. To manually stop the script, press
   <keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo>.
  </para>
 </sect1>
 <sect1 id="sec.tuning.systemtap.more">
  <title>For More Information</title>

  <para>
   This chapter only provides a short SystemTap overview. Refer to the
   following links for more information about SystemTap:
  </para>

  <variablelist>
   <varlistentry>
    <term><ulink url="http://sourceware.org/systemtap/"/>
    </term>
    <listitem>
     <para>
      SystemTap project home page.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://sourceware.org/systemtap/wiki/"/>
    </term>
    <listitem>
     <para>
      Huge collection of useful information about SystemTap, ranging from
      detailed user and developer documentation to reviews and comparisons
      with other tools, or Frequently Asked Questions and tips. Also
      contains collections of SystemTap scripts, examples and usage stories and
      lists recent talks and papers about SystemTap.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://sourceware.org/systemtap/documentation.html"/>
    </term>
    <listitem>
     <para>
      Features a <citetitle>SystemTap Tutorial</citetitle>, a <citetitle>SystemTap
      Beginner's Guide</citetitle>, a <citetitle>Tapset Developer's
      Guide</citetitle>, and a <citetitle>SystemTap Language
      Reference</citetitle> in PDF and HTML format. Also lists the relevant
      man pages.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   You can also find the SystemTap language reference and SystemTap tutorial in
   your installed system under
   <filename>/usr/share/doc/packages/systemtap</filename>. Example SystemTap
   scripts are available from the <filename>example</filename> subdirectory.
  </para>


 </sect1>
</chapter>
