<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="tuning_power.xml" id="cha.tuning.power">
 <title>Power Management</title>

 <abstract>
  <para>
   Power management aims at reducing operating costs for energy and cooling
   systems while at the same time keeping the performance of a system at a
   level that matches the current requirements. Thus, power management is
   always a matter of balancing the actual performance needs and power
   saving options for a system. Power management can be implemented and used
   at different levels of the system. A set of specifications for power
   management functions of devices and the operating system interface to
   them has been defined in the Advanced Configuration and Power Interface
   (ACPI). As power savings in server environments can primarily be achieved
   on processor level, this chapter introduces some of the main concepts and
   highlights some tools for analyzing and influencing relevant parameters.
  </para>
 </abstract>
 <sect1 id="sec.tuning.power.cpu">
  <title>Power Management at CPU Level</title>

  <para>
   At CPU level, you can control power usage in various ways: for example,
   by using idling power states (C-states), changing CPU frequency
   (P-states), and throttling the CPU (T-states). The following sections
   give a short introduction to each approach and its significance for power
   savings. Detailed specifications can be found at
   <ulink url="http://www.acpi.info/spec.htm"/>.
  </para>

  <sect2 id="sec.tuning.power.cpu.cstates">
   <title>C-States (Processor Operating States)</title>
   <para>
    Modern processors have several power saving modes called
    <literal>C-states</literal>. They reflect the capability of an idle
    processor to turn off unused components in order to save power. Whereas
    C-states have been available for laptops for some time, they are a
    rather recent trend in the server market (for example, with Intel*
    processors, C-modes are only available since
    <productname>Nehalem</productname>).
   </para>
   <para>
    When a processor runs in the <literal>C0</literal> state, it is
    executing instructions. A processor running in any other C-state is
    idle. The higher the C number, the deeper the CPU sleep mode: more
    components are shut down to save power. Deeper sleep states save more
    power, but the downside is that they have higher latency (the time the
    CPU needs to go back to <literal>C0</literal>).
   </para>
   <para>
    Some states also have submodes with different power saving latency
    levels. Which C-states and submodes are supported depends on the
    respective processor. However, <literal>C1</literal> is always
    available.
   </para>
   <para>
    <xref linkend="tab.tuning.power.cstates"/> gives an overview of the most
    common C-states.
   </para>
   <table id="tab.tuning.power.cstates">
    <title>C-States</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Mode
        </para>
       </entry>
       <entry>
        <para>
         Definition
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         C0
        </para>
       </entry>
       <entry>
        <para>
         Operational state. CPU fully turned on.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C1
        </para>
       </entry>
       <entry>
        <para>
         First idle state. Stops CPU main internal clocks via software. Bus
         interface unit and APIC are kept running at full speed.


        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C2
        </para>
       </entry>
       <entry>
        <para>
         Stops CPU main internal clocks via hardware. State where the
         processor maintains all software-visible states, but may take
         longer to wake up through interrupts.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C3
        </para>
       </entry>
       <entry>
        <para>
         Stops all CPU internal clocks. The processor does not need to keep
         its cache coherent, but maintains other states. Some processors
         have variations of the C3 state that differ in how long it takes to
         wake the processor through interrupts.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>



  </sect2>

  <sect2 id="sec.tuning.power.cpu.pstates">
   <title>P-States (Processor Performance States)</title>
   <para>
    While a processor operates (in C0 state), it can be in one of several
    CPU performance states <literal>(P-states)</literal>. Whereas C-states
    are idle states (all but C0), <literal>P-states</literal> are
    operational states that relate to CPU frequency and voltage.
   </para>
   <para>
    The higher the P-state, the lower the frequency and voltage at which the
    processor runs. The number of P-states is processor-specific and the
    implementation differs across the various types. However,
    <literal>P0</literal> is always the highest-performance state. Higher
    P-state numbers represent slower processor speeds and lower power
    consumption. For example, a processor in P3 state runs more slowly and
    uses less power than a processor running at P1 state. To operate at any
    P-state, the processor must be in the C0 state where the processor is
    working and not idling. The CPU P-states are also defined in the
    Advanced Configuration and Power Interface (ACPI) specification, see
    <ulink url="http://www.acpi.info/spec.htm"/>.
   </para>
   <para>
    C-states and P-states can vary independently of one another.
   </para>
  </sect2>

  <sect2 id="sec.tuning.cpu.power.tstates">
   <title>T-States (Processor Throttling States)</title>
   <para>
    T-states refer to throttling the processor clock to lower frequencies in
    order to reduce thermal effects. This means that the CPU is forced to be
    idle a fixed percentage of its cycles per second. Throttling states
    range from <literal>T1</literal> (the CPU has no forced idle cycles) to
    <literal>T<replaceable>n</replaceable></literal>, with the percentage of
    idle cycles increasing the greater <replaceable>n</replaceable> is.
   </para>
   <para>
    Note that throttling does not reduce voltage and since the CPU is forced
    to idle part of the time, processes will take longer to finish and will
    consume more power instead of saving any power.
   </para>
   <para>
    T-states are only useful if reducing thermal effects is the primary
    goal. Since T-states can interfere with C-states (preventing the CPU
    from reaching higher C-states), they can even increase power consumption
    in a modern CPU capable of C-states.
   </para>

  </sect2>

  <sect2 id="sec.tuning.cpu.power.turbo">
   <title>Turbo Features</title>

   <para>
    Since quite some time, CPU power consumption and performance tuning is
    not only about frequency scaling anymore. In modern processors, a
    combination of different means is used to achieve the optimum balance
    between performance and power savings: deep sleep states, traditional
    dynamic frequency scaling and hidden boost frequencies. The turbo
    features (Turbo CORE* or Turbo Boost*) of the latest AMD* or Intel*
    processors allow to dynamically increase (boost) the clock speed of
    active CPU cores while other cores are in deep sleep states. This
    increases the performance of active threads while still complying to
    Thermal Design Power (TDP) limits.
   </para>
   <para>
    However, the conditions under which a CPU core may use turbo frequencies
    are very architecture-specific. Learn how to evaluate the efficiency of
    those new features in
    <xref linkend="sec.tuning.power.tools.cpupower"/>.
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.cpufreq">
  <title>The Linux Kernel CPUfreq Infrastructure</title>



  <para>
   Processor performance states (P-states) and processor operating states
   (C-states) are the capability of a processor to switch between different
   supported operating frequencies and voltages to modulate power
   consumption.
  </para>

  <para>
   In order to dynamically scale processor frequencies at runtime, you can
   use the CPUfreq infrastructure to set a static or dynamic power policy
   for the system. Its main components are the CPUfreq subsystem
   (providing a common interface to the various low-level technologies and
   high-level policies) , the in-kernel governors (policy governors that can
   change the CPU frequency based on different criteria) and CPU-specific
   drivers that implement the technology for the specific processor.
  </para>

  <para>
   The dynamic scaling of the clock speed helps to consume less power and
   generate less heat when not operating at full capacity.
  </para>

  <sect2 id="sec.tuning.power.cpufreq.governors">
   <title>In-Kernel Governors</title>
   <para>
    You can think of the in-kernel governors as a sort of pre-configured
    power schemes for the CPU. The CPUfreq governors use P-states to
    change frequencies and lower power consumption. The dynamic governors
    can switch between CPU frequencies, based on CPU utilization to allow
    for power savings while not sacrificing performance. These governors
    also allow for some tuning so you can customize and change the frequency
    scaling behavior.
   </para>
   <para>
    The following governors are available with the CPUfreq subsystem:
   </para>
   <variablelist>
    <varlistentry>
     <term>Performance Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the highest possible for
       maximum performance. Consequently, saving power is not the focus of
       this governor.
      </para>
      <para>
       Tuning options: The range of maximum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Powersave Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the lowest possible. This can
       have severe impact on the performance, as the system will never rise
       above this frequency no matter how busy the processors are.
      </para>
      <para>
       However, using this governor often does not lead to the expected
       power savings as the highest savings can usually be achieved at idle
       through entering C-states. Due to running processes at the lowest
       frequency with the powersave governor, processes will take longer to
       finish, thus prolonging the time for the system to enter any idle
       C-states.
      </para>
      <para>
       Tuning options: The range of minimum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>On-demand Governor</term>
     <listitem>
      <para>
       The kernel implementation of a dynamic CPU frequency policy: The
       governor monitors the processor utilization. As soon as it exceeds a
       certain threshold, the governor will set the frequency to the highest
       available. If the utilization is less than the threshold, the next
       lowest frequency is used. If the system continues to be
       underutilized, the frequency is again reduced until the lowest
       available frequency is set.
      </para>
      <para>
       For <phrase os="osuse">openSUSE</phrase>, the on-demand governor is the default governor and
       the one that has the best test coverage.
      </para>
      <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks utilization, and the utilization threshold can be
       adjusted. Another parameter you might want to change for the
       on-demand governor is <literal>ignore_nice_load</literal>. For
       details, refer to
       <xref linkend="pro.tuning.power.t-states.ignore.nice"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Conservative Governor</term>
     <listitem>
      <para>
       Similar to the on-demand implementation, this governor also
       dynamically adjusts frequencies based on processor utilization,
       except that it allows for a more gradual increase in power. If
       processor utilization exceeds a certain threshold, the governor does
       not immediately switch to the highest available frequency (as the
       on-demand governor does), but only to next higher frequency
       available.
      </para>
      <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks utilization, the utilization thresholds, and the
       frequency step rate can be adjusted.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="sec.tuning.power.cpufreq.files">
   <title>Related Files and Directories</title>
   <para>
    If the CPUfreq subsystem in enabled on your system (which it is by
    default with <phrase os="osuse">openSUSE</phrase>), you can find the relevant files and directories
    under <filename>/sys/devices/system/cpu/</filename>. If you list the
    contents of this directory, you will find a
    <filename>cpu{0..x}</filename> subdirectory for each processor, and
    several other files and directories. A <filename>cpufreq</filename>
    subdirectory in each processor directory holds a number of files and
    directories that define the parameters for CPUfreq. Some of them are
    writable (for <systemitem class="username">root</systemitem>), some of them are read-only. If your system
    currently uses the on-demand or conservative governor, you will see a
    separate subdirectory for those governors in
    <filename>cpufreq</filename>, containing the parameters for the
    governors.
   </para>
   <note>
    <title>Different Processor Settings</title>
    <para>
     The settings under the <filename>cpufreq</filename> directory can be
     different for each processor. If you want to use the same policies
     across all processors, you need to adjust the parameters for each
     processor. Instead of looking up or modifying the current settings
     manually (in <filename>/sys/devices/system/cpu*/cpufreq</filename>), we
     advise to use the tools provided by the
     <systemitem class="resource">cpupower</systemitem> package
     
     for that.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.tools">
  <title>Viewing, Monitoring and Tuning Power-related Settings</title>

  <para>
   The following command line tools are available for that purpose:
  </para>

  <variablelist>
   
   <varlistentry>
    <term><xref linkend="sec.tuning.power.tools.cpupower" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      The new <command>cpupower</command> tool was designed to give an
      overview of <emphasis>all</emphasis> CPU power-related parameters that
      are supported on a given machine, including turbo (or boost) states.
      Use the tool set to view and modify settings of the kernel-related
      CPUfreq and cpuidle systems as well as other settings not related to
      frequency scaling or idle states. The integrated monitoring framework
      can access both Kernel-related parameters and hardware statistics and
      is thus ideally suited for performance benchmarks. It also helps you
      to identify the dependencies between turbo and idle states.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.power.tools.powertop" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      powerTOP combines various sources of information (analysis of
      programs, device drivers, kernel options, amounts and sources of
      interrupts waking up processors from sleep states) and shows them in
      one screen. The tool helps you to identify the reasons for unnecessary
      high power consumption (for example, processes that are mainly
      responsible for waking up a processor from its idle state) and to
      optimize your system settings to avoid these.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  

  <sect2 id="sec.tuning.power.tools.cpupower">
   <title>Using the <systemitem class="resource">cpupower</systemitem> Tools</title>
   <para>
    After installing the
    <systemitem class="resource">cpupower</systemitem> package, view
    the available <command>cpupower</command> subcommands with
    <command>cpupower --help</command>. Access the general man page
    with <command>man cpupower</command>, and the man pages of the
    subcommands with
    <command>man cpupower-<replaceable>subcommand</replaceable></command>.
   </para>
   <para>
    The subcommands <command>frequency-info</command> and
    <command>frequency-set</command> are mostly equivalent to
    <command>cpufreq-info</command> and <command>cpufreq-set</command>,
    respectively. However, they provide extended output and there are small
    differences in syntax and behavior:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <title>Syntax Differences Between <command>cpufreq*</command> and <command>cpupower</command></title>
    <listitem>
     <para>
      To specify the number of the CPU to which the command is applied, both
      commands have the <option>-c</option> option. Due to the
      command-subcommand structure, the placement of the <option>-c</option>
      option is different for <command>cpupower</command>:
     </para>
     <para>
      <command>cpupower -c 4 frequency-info</command> (versus
      <command>cpufreq-info -c 4</command>)
     </para>
     <para>
      <command>cpupower</command> lets you also specify a list of CPUs with
      <option>-c</option>. For example, the following command would affect
      the CPUs <literal>1</literal> , <literal>2</literal>,
      <literal>3</literal>, and <literal>5</literal>:
     </para>
     <para>
      <command>cpupower -c 1-3,5 frequency-set</command>
     </para>
    </listitem>
    <listitem>
     <para>
      If <command>cpufreq*</command> and <command>cpupower</command> are
      used without the <option>-c</option> option, the behavior differs:
     </para>
     <para>
      <command>cpufreq-set</command> automatically applies the command to
      CPU <literal>0</literal>, whereas
      <command>cpupower frequency-set</command> applies the command to
      all CPUs in this case. Typically, <command>cpupower *info</command>
      subcommands access only CPU <literal>0</literal>, whereas
      <command>cpufreq-info</command> accesses all CPUs, if not specified
      otherwise.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 id="sec.tuning.power.tools.cpupower.freq-info">
    <title>Viewing Current Settings with <command>cpupower</command></title>
    <para>
     Similar to <command>cpufreq-info</command>,
     <command>cpupower frequency-info</command> also shows the
     statistics of the cpufreq driver used in the Kernel. Additionally, it
     shows if turbo (boost) states are supported and enabled in the BIOS.
     Run without any options, it shows an output similar to the following:
    </para>
    <example>
     <title>Example Output of <command>cpupower frequency-info</command></title>
     <screen><?dbsuse-fo font-size="0.63em"?>
analyzing CPU 0:
  driver: acpi-cpufreq
  CPUs which run at the same hardware frequency: 0 1 2 3
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency: 10.0 us.
  hardware limits: 2.00 GHz - 2.83 GHz
  available frequency steps: 2.83 GHz, 2.34 GHz, 2.00 GHz
  available cpufreq governors: conservative, userspace, powersave, ondemand, performance
  current policy: frequency should be within 2.00 GHz and 2.83 GHz.
                  The governor "ondemand" may decide which speed to use
                  within this range.
  current CPU frequency is 2.00 GHz (asserted by call to hardware).
  boost state support:
    Supported: yes
    Active: yes
    </screen>
    </example>
    <para>
     To get the current values for all CPUs, use
     <command>cpupower -c all frequency-info</command>.
    </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.idle-info">
    <title>Viewing Kernel Idle Statistics with <command>cpupower</command></title>
    <para>
     The <command>idle-info</command> subcommand shows the statistics of the
     cpuidle driver used in the Kernel. It works on all architectures that
     use the cpuidle Kernel framework.
    </para>

    <example>
     <title>Example Output of <command>cpupower idle-info</command></title>
     <screen>CPUidle driver: acpi_idle
CPUidle governor: menu
     
Analyzing CPU 0:
Number of idle states: 3
Available idle states: C1 C2
C1:
Flags/Description: ACPI FFH INTEL MWAIT 0x0
Latency: 1
Usage: 3156464
Duration: 233680359
C2:
Flags/Description: ACPI FFH INTEL MWAIT 0x10
Latency: 1
Usage: 273007117
Duration: 103148860538</screen>
    </example>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.monitor">
    <title>Monitoring Kernel and Hardware Statistics with <command>cpupower</command></title>
    <para>
     The most powerful enhancement is the <command>monitor</command>
     subcommand. Use it to report processor topology, and monitor frequency
     and idle power state statistics over a certain period of time. The
     default interval is <literal>1</literal> second, but it can be changed
     with the <option>-i</option>. Independent processor sleep states and
     frequency counters are implemented in the tool—some retrieved
     from kernel statistics, others reading out hardware registers. The
     available monitors depend on the underlying hardware and the system.
     List them with <command>cpupower monitor -l</command>. For a
     description of the individual monitors, refer to the cpupower-monitor
     man page.
    </para>
    <para>
     The <command>monitor</command> subcommand allows you to execute
     performance benchmarks and to compare Kernel statistics with hardware
     statistics for specific workloads.
    </para>
    <example id="ex.cpupower.monitor">
     <title>Example <command>cpupower monitor</command> Output</title>
     <screen>|Mperf               || Idle_Stats  
 <co id="co.cpupower.mon.mperf"/>                      <co id="co.cpupower.mon.idle"/>       
CPU | C0   | Cx   | Freq || POLL | C1   | C2   | C3   
   0|  3.71| 96.29|  2833||  0.00|  0.00|  0.02| 96.32
   1| 100.0| -0.00|  2833||  0.00|  0.00|  0.00|  0.00
   2|  9.06| 90.94|  1983||  0.00|  7.69|  6.98| 76.45
   3|  7.43| 92.57|  2039||  0.00|  2.60| 12.62| 77.52
     </screen>
     <calloutlist>
      <callout arearefs="co.cpupower.mon.mperf">
       <para>
        Mperf shows the average frequency of a CPU, including boost
        frequencies, over a period of time. Additionally, it shows the
        percentage of time the CPU has been active (<literal>C0</literal>)
        or in any sleep state (<literal>Cx</literal>). The default sampling
        rate is <literal>1</literal> second and the values are read directly
        from the hardware registers. As the turbo states are managed by the
        BIOS, it is impossible to get the frequency values at a given
        instant. On modern processors with turbo features the Mperf monitor
        is the only way to find out about the frequency a certain CPU has
        been running in.
       </para>
      </callout>
      <callout arearefs="co.cpupower.mon.idle">
       <para>
        Idle_Stats shows the statistics of the cpuidle kernel subsystem. The
        kernel updates these values every time an idle state is entered or
        left. Therefore there can be some inaccuracy when cores are in an
        idle state for some time when the measure starts or ends.
       </para>
      </callout>
     </calloutlist>
     <para>
      Apart from the (general) monitors in the example above, other
      architecture-specific monitors are available. For detailed
      information, refer to the <command>cpupower-monitor</command> man
      page.
     </para>
    </example>
    <para>
     By comparing the values of the individual monitors, you can find
     correlations and dependencies and evaluate how well the power saving
     mechanism works for a certain workload. In
     <xref linkend="ex.cpupower.monitor" xrefstyle="select:label"/> you can
     see that CPU <literal>0</literal> is idle (the value of
     <literal>Cx</literal> is near to 100%), but runs at a very high
     frequency. Additionally, the CPUs <literal>0</literal> and
     <literal>1</literal> have the same frequency values which means that
     there is a dependency between them.
    </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.freq-set">
    <title>Modifying Current Settings with <command>cpupower</command></title>
    <para>
     Similar to <command>cpufreq-set</command>, you can use
     <command>cpupower frequency-set </command> command as <systemitem class="username">root</systemitem>
     to modify current settings. It allows you to set values for the minimum
     or maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the
     <command>cpupower-freqency-set</command> man page or run
     <command>cpupower frequency-set <option>--help</option></command>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sec.tuning.power.tools.powertop">
   <title>Monitoring Power Consumption with powerTOP</title>
   <para>
    Another useful tool for monitoring system power consumption is
    powerTOP. It helps you to identify the reasons for unnecessary high
    power consumption (for example, processes that are mainly responsible
    for waking up a processor from its idle state) and to optimize your
    system settings to avoid these. It supports both Intel and AMD
    processors. 
   </para>
   <para>
    powerTOP combines various sources of information (analysis of
    programs, device drivers, kernel options, amounts and sources of
    interrupts waking up processors from sleep states) and shows them in one
    screen. <xref linkend="ex.tuning.power.powertop"/> shows which
    information categories are available:
   </para>
   <example id="ex.tuning.power.powertop">
    <title>Example powerTOP Output</title>
    <screen>Cn               Avg  residency       P-states   (frequencies) 
<co id="co.powertop.cstates"/>                 <co id="co.powertop.avg"/>      <co id="co.powertop.residency"/>              <co id="co.powertop.pstates"/>            <co id="co.powertop.freq"/>     
C0 (cpu running)        (11.6%)       2.00 Ghz       0.1%
polling         0.0ms   ( 0.0%)       2.00 Ghz       0.0%
C1              4.4ms   (57.3%)       1.87 Ghz       0.0%
C2             10.0ms   (31.1%)       1064 Mhz      99.9%
     
     
Wakeups-from-idle per second : 11.2     interval: 5.0s <co id="co.powertop.wakeups"/>
no ACPI power usage estimate available <co id="co.powertop.power"/>
<?dbsuse-fo font-size="0.7em"?>

Top causes for wakeups: <co id="co.powertop.culprits"/>
96.2% (826.0)       &lt;interrupt&gt; : extra timer interrupt
 0.9% (  8.0)     &lt;kernel core&gt; : usb_hcd_poll_rh_status (rh_timer_func)
 0.3% (  2.4)       &lt;interrupt&gt; : megasas
 0.2% (  2.0)     &lt;kernel core&gt; : clocksource_watchdog (clocksource_watchdog)
 0.2% (  1.6)       &lt;interrupt&gt; : eth1-TxRx-0
 0.1% (  1.0)       &lt;interrupt&gt; : eth1-TxRx-4
     
[...]
    
Suggestion: <co id="co.powertop.suggestions"/> Enable SATA ALPM link power management via:
echo min_power &gt; /sys/class/scsi_host/host0/link_power_management_policy
or press the S key.</screen>
    <calloutlist>
     <callout arearefs="co.powertop.cstates">
      <para>
       The column shows the C-states. When working, the CPU is in state
       <literal>0</literal>, when resting it is in some state greater than
       <literal>0</literal>, depending on which C-states are available and
       how deep the CPU is sleeping.
      </para>
     </callout>
     <callout arearefs="co.powertop.avg">
      <para>
       The column shows average time in milliseconds spent in the particular
       C-state.
      </para>
     </callout>
     <callout arearefs="co.powertop.residency">
      <para>
       The column shows the percentages of time spent in various C-states.
       For considerable power savings during idle, the CPU should be in
       deeper C-states most of the time. In addition, the longer the average
       time spent in these C-states, the more power is saved.
      </para>
     </callout>
     <callout arearefs="co.powertop.pstates">
      <para>
       The column shows the frequencies the processor and kernel driver
       support on your system.
      </para>
     </callout>
     <callout arearefs="co.powertop.freq">
      <para>
       The column shows the amount of time the CPU cores stayed in different
       frequencies during the measuring period.
      </para>
     </callout>
     <callout arearefs="co.powertop.wakeups">
      <para>
       Shows how often the CPU is awoken per second (number of interrupts).
       The lower the number the better. The <literal>interval</literal>
       value is the powerTOP refresh interval which can be controlled with
       the <option>-t</option> option. The default time to gather data is 5
       seconds.
      </para>
     </callout>
     <callout arearefs="co.powertop.power">
      <para>
       When running powerTOP on a laptop, this line displays the ACPI
       information on how much power is currently being used and the
       estimated time until discharge of the battery. On servers, this
       information is not available.
      </para>
     </callout>
     <callout arearefs="co.powertop.culprits">
      <para>
       Shows what is causing the system to be more active than needed.
       powerTOP displays the top items causing your CPU to awake during
       the sampling period.
      </para>
     </callout>
     <callout arearefs="co.powertop.suggestions">
      <para>
       Suggestions on how to improve power usage for this machine.
      </para>
     </callout>
    </calloutlist>
   </example>
   <para>
    For more information, refer to the powerTOP project page at
    <ulink url="http://www.lesswatts.org/projects/powertop/"/>. It also
    provides tips and tricks and an informative FAQ section.
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.options">
  <title>Special Tuning Options</title>

  <para>
   The following sections highlight some of the most relevant settings that
   you might want to touch.
  </para>

  <sect2 id="sec.tuning.power.options.p-states">
   <title>Tuning Options for P-States</title>
   <para>
    The CPUfreq subsystem offers several tuning options for P-states: You
    can switch between the different governors, influence minimum or maximum
    CPU frequency to be used or change individual governor parameters.
   </para>
   <para>
    To switch to another governor at runtime, use
    <command>cpupower frequency-set</command>
     with
    the <option>-g</option> option. For example, running the following
    command (as <systemitem class="username">root</systemitem>) will activate the on-demand governor:
   </para>
   <screen>cpupower frequency-set -g ondemand</screen>
   <para>
    If you want the change in governor to persist also after a reboot or
    shutdown, use the pm-profiler as described in
    <xref linkend="sec.tuning.power.pm-profiler"/>.
   </para>
   <para>
    To set values for the minimum or maximum CPU frequency the governor may
    select, use the <option>-d</option> or <option>-u</option> option,
    respectively.
   </para>
   <para>
    Apart from the governor settings that can be influenced with
    <command>cpupower</command> or <command>cpufreq*</command>, you can also
    tune further governor parameters manually, for example,
    <xref linkend="pro.tuning.power.t-states.ignore.nice" xrefstyle="select:title"/>.
   </para>
   <procedure id="pro.tuning.power.t-states.ignore.nice">
    <title>Ignoring Nice Values in Processor Utilization</title>
    <para>
     One parameter you might want to change for the on-demand or
     conservative governor is <literal>ignore_nice_load</literal>.
    </para>
    <para>
     Each process has a niceness value associated with it. This value is
     used by the kernel to determine which processes require more processor
     time than others. The higher the nice value, the lower the priority of
     the process. Or: the <quote>nicer</quote> a process, the less CPU it
     will try to take from other processes.
    </para>
    <para>
     If the <literal>ignore_nice_load</literal> parameter for the on-demand
     or conservative governor is set to <literal>1</literal>, any processes
     with a <literal>nice</literal> value will not be counted toward the
     overall processor utilization. When <literal>ignore_nice_load</literal>
     is set to <literal>0</literal> (default value), all processes are
     counted toward the utilization. Adjusting this parameter can be useful
     if you are running something that requires a lot of processor capacity
     but you do not care about the runtime.
    </para>
    <step performance="required">
     <para>
      Change to the subdirectory of the governor whose settings you want to
      modify, for example:
     </para>
     <screen>cd /sys/devices/system/cpu/cpu0/cpufreq/conservative/</screen>
    </step>
    <step performance="required">
     <para>
      Show the current value of <filename>ignore_nice_load</filename> with:
     </para>
     <screen>cat ignore_nice_load</screen>
    </step>
    <step performance="required">
     <para>
      To set the value to <literal>1</literal>, execute:
     </para>
     <screen>echo 1 &gt; ignore_nice_load</screen>
    </step>
   </procedure>
   <tip>
    <title>Using the Same Value for All Cores</title>
    <para>
     When setting the <literal>ignore_nice_load</literal> value for
     <literal>cpu0</literal>, the same value is automatically used for all
     cores. In this case, you do not need to repeat the steps above for each
     of the processors where you want to modify this governor parameter.
    </para>
   </tip>
   <para>
    Another parameter that significantly impacts the performance loss caused
    by dynamic frequency scaling is the sampling rate (rate at which the
    governor checks the current CPU load and adjusts the processor's
    frequency accordingly). Its default value depends on a BIOS value and it
    should be as low as possible. However, in modern systems, an appropriate
    sampling rate is set by default and does not need manual intervention.
   </para>
  </sect2>

  <sect2 id="sec.tuning.power.options-c.states">
   <title>Tuning Options for C-states</title>
   <para>
    By default, <phrase os="osuse">openSUSE</phrase> uses C-states appropriately. The only
    parameter you might want to touch for optimization is the
    <literal>sched_mc_power_savings</literal> scheduler. Instead of
    distributing a work load across all cores with the effect that all cores
    are utilized only at a minimum level, the kernel can try to schedule
    processes on as few cores as possible so that the others can go idle.
    This helps to save power as it allows some processors to be idle for a
    longer time so they can reach a higher C-state. However, the actual
    savings depend on a number of factors, for example how many processors
    are available and which C-states are supported by them (especially
    deeper ones such as <literal>C3</literal> to <literal>C6</literal>).
   </para>
   <para>
    If <literal>sched_mc_power_savings</literal> is set to
    <literal>0</literal> (default value), no special scheduling is done. If
    it is set to <literal>1</literal>, the scheduler tries to consolidate
    the work onto the fewest number of processors possible in the case that
    all processors are a little busy.

    To modify this parameter, proceed as follows:
   </para>
   <procedure id="pro.tuning.power.c-states.ignore.scheduler">
    <title>Scheduling Processes on Cores</title>
    <step performance="required">
     <para>
      Become <systemitem class="username">root</systemitem> on a command line.
     </para>
    </step>
    <step performance="required">
     <para>
      To view the current value of
      <filename>sched_mc_power_savings</filename>, use the following
      command:
     </para>
     <screen>cpupower info -m</screen>
    </step>
    <step performance="required">
     <para>
      To set <literal>sched_mc_power_savings</literal> to
      <literal>1</literal>, execute:
     </para>
     <screen>cpupower set -m 1</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.pm-profiler">
  <title>Creating and Using Power Management Profiles</title>

  <para>
   <phrase os="osuse">openSUSE</phrase> includes pm-profiler, intended for server use. It is a
   script infrastructure to enable or disable certain power management
   functions via configuration files. It allows you to define different
   profiles, each having a specific configuration file for defining
   different settings. A configuration template for new profiles can be
   found at
   <filename>/usr/share/doc/packages/pm-profiler/config.template</filename>.
   The template contains a number of parameters you can use for your
   profile, including comments on usage and links to further documentation.
   The individual profiles are stored in
   <filename>/etc/pm-profiler/</filename>. The profile that will be
   activated on system start, is defined in
   <filename>/etc/pm-profiler.conf</filename>.
  </para>

  <procedure id="pro.tuning.power.pm-profile">
   <title>Creating and Switching Power Profiles</title>
   <para>
    To create a new profile, proceed as follows:
   </para>
   <step performance="required">
    <para>
     Create a directory in <filename>/etc/pm-profiler/</filename>,
     containing the profile name, for example:
    </para>
    <screen> mkdir /etc/pm-profiler/testprofile</screen>
   </step>
   <step performance="required">
    <para>
     To create the configuration file for the new profile, copy the profile
     template to the newly created directory:
    </para>
    <screen>cp /usr/share/doc/packages/pm-profiler/config.template \
     /etc/pm-profiler/testprofile/config</screen>
   </step>
   <step performance="required">
    <para>
     Edit the settings in
     <filename>/etc/pm-profiler/testprofile/config</filename> and save the
     file. You can also remove variables that you do not need—they
     will be handled like empty variables, the settings will not be touched
     at all.
    </para>
   </step>
   <step performance="required">
    <para>
     Edit <filename>/etc/pm-profiler.conf</filename>. The
     <systemitem>PM_PROFILER_PROFILE</systemitem> variable defines which
     profile will be activated on system start. If it has no value, the
     default system or kernel settings will be used. To set the newly
     created profile:
    </para>
    <screen>PM_PROFILER_PROFILE="<replaceable>testprofile</replaceable>"
    </screen>
    <para>
     The profile name you enter here must match the name you used in the
     path to the profile configuration file
     (<filename>/etc/pm-profiler/testprofile/config</filename>), not
     necessarily the <literal>NAME</literal> you used for the profile in the
     <filename>/etc/pm-profiler/testprofile/config</filename>.
    </para>
   </step>
   <step performance="required">
    <para>
     To activate the profile, run
    </para>
    <screen>rcpm-profiler start</screen>
    <para>
     or
    </para>
    <screen>/usr/lib/pm-profiler/enable-profile testprofile </screen>
   </step>
  </procedure>

  <para>
   Though you have to manually create or modify a profile by editing the
   respective profile configuration file, you can use YaST to switch
   between different profiles. Start YaST and select <menuchoice>
   <guimenu>System</guimenu> <guimenu>Power Management</guimenu>
   </menuchoice> to open the <guimenu>Power Management Settings</guimenu>.
   Alternatively, become <systemitem class="username">root</systemitem> and execute <command>yast2
   power-management</command> on a command line. The drop-down list shows
   the available profiles. <literal>Default</literal> means that the system
   default settings will be kept. Select the profile to use and click
   <guimenu>Finish</guimenu>.
  </para>
 </sect1>
 <sect1 id="sec.tuning.power.trouble">
  <title>Troubleshooting</title>

  <variablelist>
   <varlistentry>
    <term>BIOS options enabled?</term>
    <listitem>
     <para>
      In order to make use of C-states or P-states, check your BIOS options:
     </para>
     <itemizedlist mark="bullet" spacing="normal">
      <listitem>
       <para>
        To use C-states, make sure to enable <literal>CPU C State</literal>
        or similar options to benefit from power savings at idle.
       </para>
      </listitem>
      <listitem>
       <para>
        To use P-states and the CPUfreq governors, make sure to enable
        <literal>Processor Performance States</literal> options or similar.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      In case of a CPU upgrade, make sure to upgrade your BIOS, too. The
      BIOS needs to know the new CPU and its valid frequencies steps in
      order to pass this information on to the operating system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>CPUfreq subsystem enabled?</term>
    <listitem>
     <para>
      In <phrase os="osuse">openSUSE</phrase>, the CPUfreq subsystem is enabled by default. To
      find out if the subsystem is currently enabled, check for the
      following path in your system:
      <filename>/sys/devices/system/cpu/cpufreq</filename> (or
      <filename>/sys/devices/system/cpu/cpu*/cpufreq</filename> for machines
      with multiple cores). If the <filename>cpufreq</filename> subdirectory
      exists, the subsystem is enabled.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Log file information?</term>
    <listitem>
     <para>
      Check syslog (usually <filename>/var/log/messages</filename>) for any
      output regrading the CPUfreq subsystem. Only severe errors are
      reported there.
     </para>
     <para>
      If you suspect problems with the CPUfreq subsystem on your machine,
      you can also enable additional debug output. To do so, either use
      <command>cpufreq.debug=7</command> as boot parameter or execute the
      following command as <systemitem class="username">root</systemitem>:
     </para>
     <screen>echo 7 &gt; /sys/module/cpufreq/parameters/debug</screen>
     <para>
      This will cause CPUfreq to log more information to
      <command>dmesg</command> on state transitions, which is useful for
      diagnosis. But as this additional output of kernel messages can be
      rather comprehensive, use it only if you are fairly sure that a
      problem exists.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.tuning.power.more">
  <title>For More Information</title>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     A threepart, comprehensive article about tuning components with regards
     to power efficiency is available at the following URLs:
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 1: The CPUfreq
       subsystem</citetitle>, available at
       <ulink url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-1/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 2: General and
       governor-specific settings</citetitle>, available at
       <ulink url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-2/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 3: Tuning
       results</citetitle>, available at
       <ulink url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-3/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/>
      </para>
     </listitem>
    </itemizedlist>
   </listitem>
   <listitem>
    <para>
     The LessWatts.org project deals with how to save power, reduce costs
     and increase efficiency on Linux systems. Find the project home page at
     <ulink url="http://www.lesswatts.org/"/>. The project page also
     holds an informative FAQs section at
     <ulink url="http://www.lesswatts.org/documentation/faq/index.php"/> and
     provides useful tips and tricks. For tips dealing with the CPU level,
     refer to <ulink url="http://www.lesswatts.org/tips/cpu.php"/>.
     For more information about powerTOP, refer to
     <ulink url="http://www.lesswatts.org/projects/powertop/"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Platforms with a Baseboard Management Controller (BMC) may have
     additional power management configuration options accessible via the
     service processor. These configurations are vendor specific and
     therefore not subject of this guide. For more information, refer to the
     manuals provided by your vendor. For example, <citetitle>HP ProLiant
     Server Power Management on SUSE Linux Enterprise Server
     11—Integration Note </citetitle> provides detailed information
     how the HP platform specific power management features interact with
     the Linux Kernel. The paper is available from
     <ulink url="http://h18004.www1.hp.com/products/servers/technology/whitepapers/os-techwp.html"/>.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
